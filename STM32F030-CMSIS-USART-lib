//  Minimalist UART
//  ===============
//  Hardware: STM32030xx, USB-Serial dongle
//  Software: arm-none-eabi toolchain, CMSIS, Windows, PuTTY (or other serial terminal
//  program)
//  Mike Shegedin, 04/2023
//
//  Summary:
//  --------
//  Set up the USART for UART (RS-232) IO with character RxTx capability.
//  Initiall output "Hello World" with first 'H' output as a character and
//  'ello World!" output as a string. Then echo any terminal input back to
//  the terminal. Indicate <Return> by displaying '<RETURN>'.
//
//  USART1_Tx = PA2, Alternate Function 1
//  USART1_Rx = PA3, Alternate Function 1
//
//  Baudrate Calculation
//  --------------------
//  Assuming the internal RC clock: f(CK) = 8 MHz
//  Mantissa = whole part of f(CK) / (16 * Baud)
//  Fraction = remainder of above * 16
//      f(CK)    Baud     Mantissa   Fraction
//      -----   -------   --------   --------
//      8 MHz     9,600      52          1
//              115,200       4          5
//              460,800       1          1
//              500,000       1          0
//
//  If calculating in program:
//      uartDiv  = freqClk / baud
//      mantissa = uartDiv / 16
//      fraction = uartDiv % 16
//
//  Steps to Set Up UART on STM32F030xx:
//  ------------------------------------
//  1. Enable GPIO Port A via RCC->AHBENR
//  2. Set PA2 and PA3 as Alternate Functions via GPIOA->MODER
//  3. Set Alternate Function 1 for PA2 and PA3 via GPIOA->AFR[0]
//  4. Enable USART1 perpheral via RCC->APB2ENR
//  5. Set Baudrate via USART1->BRR
//  6. Enable (turn on) Tx, Rx, and USART via USART1->CR1

#include "stm32f030x6.h"  // Primary CMSIS header file

// putchar
// Output a single character to the USART Tx pin (PA2)
int
putchar(int c)
{
    while( !(USART1->ISR & USART_ISR_TXE ) )
    {   // Wait until the transmit data register is empty
    }
    USART1->TDR = c; // Put character into the data register.
    return c;
}

// puts
// Output a string to the USART Tx pin (PA2). Adds linefeed after string.
// String should be null turminated (standard C string)
int
puts( const char *s )
{
    while( *s )
        putchar( *s++ );
     putchar('\n');
     return 1;
}

// getchar
// Waits for a character on the serial port and returns the character
// when received.
int
getchar()
{
    while( !( USART1->ISR & USART_ISR_RXNE ) )
    {
    }
    return USART1->RDR;
}


// setupUSART
// Initializes USART port and Tx/Rx pins and readies the port to receive and
// transmit data.
void
setupUSART( void )
{

    // Enable GPIO Port A
    RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    // Set PA2 and PA3 as Alternate Functions
    GPIOA->MODER |= (0b10 << GPIO_MODER_MODER2_Pos); // USART1_TX/PA2/AF1/Pin8
    GPIOA->MODER |= (0b10 << GPIO_MODER_MODER3_Pos); // USART1_RX/PA3/AF1/Pin9
    // Set PA2 and PA3 as Alternate Function 1
    GPIOA->AFR[0] |= (0b0001 << GPIO_AFRL_AFRL2_Pos);
    GPIOA->AFR[0] |= (0b0001 << GPIO_AFRL_AFRL3_Pos);
    // Enable USART1 peripheral
    RCC->APB2ENR |= RCC_APB2ENR_USART1EN;
    // Set Baudrate by loading the baudrate Mantissa and Fractional part as described above
    USART1->BRR = (4<<USART_BRR_DIV_MANTISSA_Pos) | (5<<USART_BRR_DIV_FRACTION_Pos);
    // Enable (turn on) Tx, Rx, and USART
    USART1->CR1 = (USART_CR1_TE | USART_CR1_RE | USART_CR1_UE) ;
    // End of Setup
}


int
main( void )
{
    int c; // Will be character to echo

    setupUSART();

    // Send and receive some text...

    putchar('H');           // Output one character 'H' to terminal
    puts("ello World!");    // Output rest of 'ellow World!'

    puts("Now type stuff on the terminal to be echoed...");

    while( 1 )                // Endless looop to echo anything typed into the termainal
    {                         // back out to the terminal. Echo '<RETURN>' at each CR character.
        c = getchar();
        putchar(c);
        if( c == '\r' )
            puts("<RETURN>");
    }
    return 1;
} // End main.c
